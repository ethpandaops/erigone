diff --git a/cmd/utils/flags.go b/cmd/utils/flags.go
index 1de082d..e22653a 100644
--- a/cmd/utils/flags.go
+++ b/cmd/utils/flags.go
@@ -1152,6 +1152,12 @@ var (
 		Usage: "Port for MCP RPC server",
 		Value: 8553,
 	}
+	// Xatu: Xatu execution processor config
+	XatuConfigFlag = cli.StringFlag{
+		Name:  "xatu.config",
+		Usage: "Path to Xatu execution processor config file, or 'simulation' for simulation-only mode",
+		Value: "",
+	}
 )
 
 var MetricFlags = []cli.Flag{&MetricsEnabledFlag, &MetricsHTTPFlag, &MetricsPortFlag}
@@ -1947,6 +1953,9 @@ func SetEthConfig(ctx *cli.Context, nodeConfig *nodecfg.Config, cfg *ethconfig.C
 	cfg.AllowAA = ctx.Bool(AAFlag.Name)
 	cfg.Ethstats = ctx.String(EthStatsURLFlag.Name)
 
+	// Xatu: Set Xatu execution processor configuration
+	cfg.XatuConfig = ctx.String(XatuConfigFlag.Name)
+
 	if ctx.Bool(ExperimentalConcurrentCommitmentFlag.Name) {
 		// cfg.ExperimentalConcurrentCommitment = true
 		statecfg.ExperimentalConcurrentCommitment = true
diff --git a/common/math/integer.go b/common/math/integer.go
index dc353bf..52a46f1 100644
--- a/common/math/integer.go
+++ b/common/math/integer.go
@@ -124,3 +124,12 @@ func SafeAdd(x, y uint64) (uint64, bool) {
 	sum, carryOut := bits.Add64(x, y, 0)
 	return sum, carryOut != 0
 }
+
+// SafeSubClamp returns x-y, clamped to 0 if y > x (prevents underflow).
+// Used by gas repricing simulation where custom values may cause underflow.
+func SafeSubClamp(x, y uint64) uint64 {
+	if y > x {
+		return 0
+	}
+	return x - y
+}
diff --git a/execution/protocol/state_transition.go b/execution/protocol/state_transition.go
index 8ed4dd7..7f871a3 100644
--- a/execution/protocol/state_transition.go
+++ b/execution/protocol/state_transition.go
@@ -493,6 +493,10 @@ func (st *StateTransition) TransitionDb(refunds bool, gasBailout bool) (result *
 
 	// Check clauses 4-5, subtract intrinsic gas if everything is correct
 	gas, floorGas7623, overflow := fixedgas.IntrinsicGas(st.data, uint64(len(accessTuples)), uint64(accessTuples.StorageKeys()), contractCreation, rules.IsHomestead, rules.IsIstanbul, isEIP3860, rules.IsPrague, false, uint64(len(auths)))
+	if st.evm.GasSchedule != nil && st.evm.GasSchedule.HasIntrinsicOverrides() {
+		gas, floorGas7623 = vm.CalcCustomIntrinsicGas(st.evm.GasSchedule, st.data, uint64(len(accessTuples)), uint64(accessTuples.StorageKeys()), contractCreation, rules.IsHomestead, rules.IsIstanbul, isEIP3860, rules.IsPrague, false, uint64(len(auths)))
+		overflow = false
+	}
 	if overflow {
 		return nil, ErrGasUintOverflow
 	}
diff --git a/execution/vm/contracts.go b/execution/vm/contracts.go
index b0d2aa8..85e1804 100644
--- a/execution/vm/contracts.go
+++ b/execution/vm/contracts.go
@@ -299,9 +299,12 @@ func ActivePrecompiles(rules *chain.Rules) []accounts.Address {
 // - the returned bytes,
 // - the _remaining_ gas,
 // - any error that occurred
-func RunPrecompiledContract(p PrecompiledContract, input []byte, suppliedGas uint64, tracer *tracing.Hooks,
+func RunPrecompiledContract(p PrecompiledContract, input []byte, suppliedGas uint64, tracer *tracing.Hooks, schedule *GasSchedule,
 ) (ret []byte, remainingGas uint64, err error) {
 	gasCost := p.RequiredGas(input)
+	if schedule != nil {
+		gasCost = PrecompileGasWithOverrides(schedule, p.Name(), input, gasCost)
+	}
 	if suppliedGas < gasCost {
 		return nil, 0, ErrOutOfGas
 	}
diff --git a/execution/vm/contracts_fuzz_test.go b/execution/vm/contracts_fuzz_test.go
index f813f63..81524ce 100644
--- a/execution/vm/contracts_fuzz_test.go
+++ b/execution/vm/contracts_fuzz_test.go
@@ -36,7 +36,7 @@ func FuzzPrecompiledContracts(f *testing.F) {
 			return
 		}
 		inWant := string(input)
-		RunPrecompiledContract(p, input, gas, nil)
+		RunPrecompiledContract(p, input, gas, nil, nil)
 		if inHave := string(input); inWant != inHave {
 			t.Errorf("Precompiled %v modified input data", a)
 		}
diff --git a/execution/vm/contracts_test.go b/execution/vm/contracts_test.go
index 2d804f3..f63da0b 100644
--- a/execution/vm/contracts_test.go
+++ b/execution/vm/contracts_test.go
@@ -107,7 +107,7 @@ func testPrecompiled(t *testing.T, addr string, test precompiledTest) {
 	gas := p.RequiredGas(in)
 	t.Run(fmt.Sprintf("%s-Gas=%d", test.Name, gas), func(t *testing.T) {
 		t.Parallel()
-		if res, _, err := RunPrecompiledContract(p, in, gas, nil); err != nil {
+		if res, _, err := RunPrecompiledContract(p, in, gas, nil, nil); err != nil {
 			t.Error(err)
 		} else if common.Bytes2Hex(res) != test.Expected {
 			t.Errorf("Expected %v, got %v", test.Expected, common.Bytes2Hex(res))
@@ -130,7 +130,7 @@ func testPrecompiledOOG(t *testing.T, addr string, test precompiledTest) {
 
 	t.Run(fmt.Sprintf("%s-Gas=%d", test.Name, gas), func(t *testing.T) {
 		t.Parallel()
-		_, _, err := RunPrecompiledContract(p, in, gas, nil)
+		_, _, err := RunPrecompiledContract(p, in, gas, nil, nil)
 		if err.Error() != "out of gas" {
 			t.Errorf("Expected error [out of gas], got [%v]", err)
 		}
@@ -148,7 +148,7 @@ func testPrecompiledFailure(addr string, test precompiledFailureTest, t *testing
 	gas := p.RequiredGas(in)
 	t.Run(test.Name, func(t *testing.T) {
 		t.Parallel()
-		_, _, err := RunPrecompiledContract(p, in, gas, nil)
+		_, _, err := RunPrecompiledContract(p, in, gas, nil, nil)
 		if err == nil || err.Error() != test.ExpectedError {
 			t.Errorf("Expected error [%v], got [%v]", test.ExpectedError, err)
 		}
@@ -180,7 +180,7 @@ func benchmarkPrecompiled(b *testing.B, addr string, test precompiledTest) {
 		bench.ResetTimer()
 		for i := 0; i < bench.N; i++ {
 			copy(data, in)
-			res, _, err = RunPrecompiledContract(p, data, reqGas, nil)
+			res, _, err = RunPrecompiledContract(p, data, reqGas, nil, nil)
 		}
 		bench.StopTimer()
 		elapsed := max(uint64(time.Since(start)), 1)
@@ -264,7 +264,7 @@ func TestPrecompiledModExpPotentialOutOfRange(t *testing.T) {
 	hexString := "0x0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000ffffffffffffffff0000000000000000000000000000000000000000000000000000000000000000ee"
 	input := hexutil.MustDecode(hexString)
 	maxGas := uint64(math.MaxUint64)
-	_, _, err := RunPrecompiledContract(modExpContract, input, maxGas, nil)
+	_, _, err := RunPrecompiledContract(modExpContract, input, maxGas, nil, nil)
 	require.NoError(t, err)
 }
 
@@ -275,52 +275,52 @@ func TestPrecompiledModExpInputEip7823(t *testing.T) {
 	// length_of_EXPONENT = 1024; everything else is zero
 	in := common.Hex2Bytes("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000")
 	gas := pragueModExp.RequiredGas(in)
-	res, _, err := RunPrecompiledContract(pragueModExp, in, gas, nil)
+	res, _, err := RunPrecompiledContract(pragueModExp, in, gas, nil, nil)
 	require.NoError(t, err)
 	assert.Equal(t, "", common.Bytes2Hex(res))
 	gas = osakaModExp.RequiredGas(in)
-	_, _, err = RunPrecompiledContract(osakaModExp, in, gas, nil)
+	_, _, err = RunPrecompiledContract(osakaModExp, in, gas, nil, nil)
 	require.NoError(t, err)
 	assert.Equal(t, "", common.Bytes2Hex(res))
 
 	// length_of_EXPONENT = 1025; everything else is zero
 	in = common.Hex2Bytes("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004010000000000000000000000000000000000000000000000000000000000000000")
 	gas = pragueModExp.RequiredGas(in)
-	res, _, err = RunPrecompiledContract(pragueModExp, in, gas, nil)
+	res, _, err = RunPrecompiledContract(pragueModExp, in, gas, nil, nil)
 	require.NoError(t, err)
 	assert.Equal(t, "", common.Bytes2Hex(res))
 	gas = osakaModExp.RequiredGas(in)
-	_, _, err = RunPrecompiledContract(osakaModExp, in, gas, nil)
+	_, _, err = RunPrecompiledContract(osakaModExp, in, gas, nil, nil)
 	assert.ErrorIs(t, err, errModExpExponentLengthTooLarge)
 
 	// length_of_EXPONENT = 2048; everything else is zero
 	in = common.Hex2Bytes("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000")
 	gas = pragueModExp.RequiredGas(in)
-	res, _, err = RunPrecompiledContract(pragueModExp, in, gas, nil)
+	res, _, err = RunPrecompiledContract(pragueModExp, in, gas, nil, nil)
 	require.NoError(t, err)
 	assert.Equal(t, "", common.Bytes2Hex(res))
 	gas = osakaModExp.RequiredGas(in)
-	_, _, err = RunPrecompiledContract(osakaModExp, in, gas, nil)
+	_, _, err = RunPrecompiledContract(osakaModExp, in, gas, nil, nil)
 	assert.ErrorIs(t, err, errModExpExponentLengthTooLarge)
 
 	// length_of_EXPONENT = 2^32; everything else is zero
 	in = common.Hex2Bytes("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000")
 	gas = pragueModExp.RequiredGas(in)
-	res, _, err = RunPrecompiledContract(pragueModExp, in, gas, nil)
+	res, _, err = RunPrecompiledContract(pragueModExp, in, gas, nil, nil)
 	require.NoError(t, err)
 	assert.Equal(t, "", common.Bytes2Hex(res))
 	gas = osakaModExp.RequiredGas(in)
-	_, _, err = RunPrecompiledContract(osakaModExp, in, gas, nil)
+	_, _, err = RunPrecompiledContract(osakaModExp, in, gas, nil, nil)
 	assert.ErrorIs(t, err, errModExpExponentLengthTooLarge)
 
 	// length_of_EXPONENT = 2^64; everything else is zero
 	in = common.Hex2Bytes("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000")
 	gas = pragueModExp.RequiredGas(in)
-	res, _, err = RunPrecompiledContract(pragueModExp, in, gas, nil)
+	res, _, err = RunPrecompiledContract(pragueModExp, in, gas, nil, nil)
 	require.NoError(t, err)
 	assert.Equal(t, "", common.Bytes2Hex(res))
 	gas = osakaModExp.RequiredGas(in)
-	_, _, err = RunPrecompiledContract(osakaModExp, in, gas, nil)
+	_, _, err = RunPrecompiledContract(osakaModExp, in, gas, nil, nil)
 	assert.ErrorIs(t, err, errModExpExponentLengthTooLarge)
 }
 
diff --git a/execution/vm/evm.go b/execution/vm/evm.go
index d69c22b..99460f1 100644
--- a/execution/vm/evm.go
+++ b/execution/vm/evm.go
@@ -92,6 +92,10 @@ type EVM struct {
 
 	readOnly   bool   // Whether to throw on stateful modifications
 	returnData []byte // Last CALL's return data for subsequent reuse
+
+	// GasSchedule allows overriding gas costs for simulation.
+	// When nil, standard params.X values are used.
+	GasSchedule *GasSchedule
 }
 
 // NewEVM returns a new EVM. The returned EVM is not thread safe and should
@@ -247,7 +251,7 @@ func (evm *EVM) call(typ OpCode, caller accounts.Address, callerAddress accounts
 
 	// It is allowed to call precompiles, even via delegatecall
 	if isPrecompile {
-		ret, gas, err = RunPrecompiledContract(p, input, gas, evm.Config().Tracer)
+		ret, gas, err = RunPrecompiledContract(p, input, gas, evm.Config().Tracer, evm.GasSchedule)
 	} else if len(code) == 0 {
 		// If the account has no code, we can abort here
 		// The depth-check is already done, and precompiles handled above
@@ -485,7 +489,7 @@ func (evm *EVM) create(caller accounts.Address, codeAndHash *codeAndHash, gasRem
 	// be stored due to not enough gas, set an error when we're in Homestead and let it be handled
 	// by the error checking condition below.
 	if err == nil {
-		createDataGas := uint64(len(ret)) * params.CreateDataGas
+		createDataGas := uint64(len(ret)) * evm.GasSchedule.GetOr(GasKeyCreateData, params.CreateDataGas)
 		var ok bool
 		if gasRemaining, ok = useGas(gasRemaining, createDataGas, evm.Config().Tracer, tracing.GasChangeCallCodeStorage); ok {
 			evm.intraBlockState.SetCode(address, ret)
diff --git a/execution/vm/export_test.go b/execution/vm/export_test.go
index 97ff0ec..566f941 100644
--- a/execution/vm/export_test.go
+++ b/execution/vm/export_test.go
@@ -17,5 +17,5 @@
 package vm
 
 func MemoryGasCost(callContext *CallContext, newMemSize uint64) (uint64, error) {
-	return memoryGasCost(callContext, newMemSize)
+	return memoryGasCost(nil, callContext, newMemSize)
 }
diff --git a/execution/vm/gas.go b/execution/vm/gas.go
index ff18f09..719b0a8 100644
--- a/execution/vm/gas.go
+++ b/execution/vm/gas.go
@@ -39,6 +39,10 @@ const (
 // As part of EIP 150 (TangerineWhistle), the returned gas is gas - base * 63 / 64.
 func callGas(isEip150 bool, availableGas, base uint64, callCost *uint256.Int) (uint64, error) {
 	if isEip150 {
+		// Guard against underflow: if availableGas < base, no gas can be passed to the child call
+		if availableGas < base {
+			return 0, nil
+		}
 		availableGas = availableGas - base
 		gas := availableGas - availableGas/64
 		// If the bit length exceeds 64 bit we know that the newly calculated "gas" for EIP150
diff --git a/execution/vm/gas_table.go b/execution/vm/gas_table.go
index 7bac889..f71e151 100644
--- a/execution/vm/gas_table.go
+++ b/execution/vm/gas_table.go
@@ -32,7 +32,7 @@ import (
 
 // memoryGasCost calculates the quadratic gas for memory expansion. It does so
 // only for the memory region that is expanded, not the total memory.
-func memoryGasCost(callContext *CallContext, newMemSize uint64) (uint64, error) {
+func memoryGasCost(evm *EVM, callContext *CallContext, newMemSize uint64) (uint64, error) {
 	if newMemSize == 0 {
 		return 0, nil
 	}
@@ -49,7 +49,7 @@ func memoryGasCost(callContext *CallContext, newMemSize uint64) (uint64, error)
 
 	if newMemSize > uint64(callContext.Memory.Len()) {
 		square := newMemSizeWords * newMemSizeWords
-		linCoef := newMemSizeWords * params.MemoryGas
+		linCoef := newMemSizeWords * evm.GasSchedule.GetOr(GasKeyMemory, params.MemoryGas)
 		quadCoef := square / params.QuadCoeffDiv
 		newTotalFee := linCoef + quadCoef
 
@@ -70,9 +70,9 @@ func memoryGasCost(callContext *CallContext, newMemSize uint64) (uint64, error)
 // EXTCODECOPY (stack position 3)
 // RETURNDATACOPY (stack position 2)
 func memoryCopierGas(stackpos int) gasFunc {
-	return func(_ *EVM, callContext *CallContext, scaopeGas uint64, memorySize uint64) (uint64, error) {
+	return func(evm *EVM, callContext *CallContext, scaopeGas uint64, memorySize uint64) (uint64, error) {
 		// Gas for expanding the memory
-		gas, err := memoryGasCost(callContext, memorySize)
+		gas, err := memoryGasCost(evm, callContext, memorySize)
 		if err != nil {
 			return 0, err
 		}
@@ -82,7 +82,7 @@ func memoryCopierGas(stackpos int) gasFunc {
 			return 0, ErrGasUintOverflow
 		}
 
-		if words, overflow = math.SafeMul(ToWordSize(words), params.CopyGas); overflow {
+		if words, overflow = math.SafeMul(ToWordSize(words), evm.GasSchedule.GetOr(GasKeyCopy, params.CopyGas)); overflow {
 			return 0, ErrGasUintOverflow
 		}
 
@@ -224,26 +224,26 @@ func gasSStoreEIP2200(evm *EVM, callContext *CallContext, availableGas uint64, m
 }
 
 func makeGasLog(n uint64) gasFunc {
-	return func(_ *EVM, callContext *CallContext, availableGas uint64, memorySize uint64) (uint64, error) {
+	return func(evm *EVM, callContext *CallContext, availableGas uint64, memorySize uint64) (uint64, error) {
 		requestedSize, overflow := callContext.Stack.Back(1).Uint64WithOverflow()
 		if overflow {
 			return 0, ErrGasUintOverflow
 		}
 
-		gas, err := memoryGasCost(callContext, memorySize)
+		gas, err := memoryGasCost(evm, callContext, memorySize)
 		if err != nil {
 			return 0, err
 		}
 
-		if gas, overflow = math.SafeAdd(gas, params.LogGas); overflow {
+		if gas, overflow = math.SafeAdd(gas, evm.GasSchedule.GetOr(GasKeyLog, params.LogGas)); overflow {
 			return 0, ErrGasUintOverflow
 		}
-		if gas, overflow = math.SafeAdd(gas, n*params.LogTopicGas); overflow {
+		if gas, overflow = math.SafeAdd(gas, n*evm.GasSchedule.GetOr(GasKeyLogTopic, params.LogTopicGas)); overflow {
 			return 0, ErrGasUintOverflow
 		}
 
 		var memorySizeGas uint64
-		if memorySizeGas, overflow = math.SafeMul(requestedSize, params.LogDataGas); overflow {
+		if memorySizeGas, overflow = math.SafeMul(requestedSize, evm.GasSchedule.GetOr(GasKeyLogData, params.LogDataGas)); overflow {
 			return 0, ErrGasUintOverflow
 		}
 		if gas, overflow = math.SafeAdd(gas, memorySizeGas); overflow {
@@ -253,8 +253,8 @@ func makeGasLog(n uint64) gasFunc {
 	}
 }
 
-func gasKeccak256(_ *EVM, callContext *CallContext, availableGas uint64, memorySize uint64) (uint64, error) {
-	gas, err := memoryGasCost(callContext, memorySize)
+func gasKeccak256(evm *EVM, callContext *CallContext, availableGas uint64, memorySize uint64) (uint64, error) {
+	gas, err := memoryGasCost(evm, callContext, memorySize)
 	if err != nil {
 		return 0, err
 	}
@@ -262,7 +262,7 @@ func gasKeccak256(_ *EVM, callContext *CallContext, availableGas uint64, memoryS
 	if overflow {
 		return 0, ErrGasUintOverflow
 	}
-	if wordGas, overflow = math.SafeMul(ToWordSize(wordGas), params.Keccak256WordGas); overflow {
+	if wordGas, overflow = math.SafeMul(ToWordSize(wordGas), evm.GasSchedule.GetOr(GasKeyKeccak256Word, params.Keccak256WordGas)); overflow {
 		return 0, ErrGasUintOverflow
 	}
 	if gas, overflow = math.SafeAdd(gas, wordGas); overflow {
@@ -274,8 +274,8 @@ func gasKeccak256(_ *EVM, callContext *CallContext, availableGas uint64, memoryS
 // pureMemoryGascost is used by several operations, which aside from their
 // static cost have a dynamic cost which is solely based on the memory
 // expansion
-func pureMemoryGascost(_ *EVM, callContext *CallContext, availableGas uint64, memorySize uint64) (uint64, error) {
-	return memoryGasCost(callContext, memorySize)
+func pureMemoryGascost(evm *EVM, callContext *CallContext, availableGas uint64, memorySize uint64) (uint64, error) {
+	return memoryGasCost(evm, callContext, memorySize)
 }
 
 var (
@@ -287,8 +287,8 @@ var (
 	gasCreate  = pureMemoryGascost
 )
 
-func gasCreate2(_ *EVM, callContext *CallContext, availableGas uint64, memorySize uint64) (uint64, error) {
-	gas, err := memoryGasCost(callContext, memorySize)
+func gasCreate2(evm *EVM, callContext *CallContext, availableGas uint64, memorySize uint64) (uint64, error) {
+	gas, err := memoryGasCost(evm, callContext, memorySize)
 	if err != nil {
 		return 0, err
 	}
@@ -297,7 +297,7 @@ func gasCreate2(_ *EVM, callContext *CallContext, availableGas uint64, memorySiz
 		return 0, ErrGasUintOverflow
 	}
 	numWords := ToWordSize(size)
-	wordGas, overflow := math.SafeMul(numWords, params.Keccak256WordGas)
+	wordGas, overflow := math.SafeMul(numWords, evm.GasSchedule.GetOr(GasKeyKeccak256Word, params.Keccak256WordGas))
 	if overflow {
 		return 0, ErrGasUintOverflow
 	}
@@ -308,8 +308,8 @@ func gasCreate2(_ *EVM, callContext *CallContext, availableGas uint64, memorySiz
 	return gas, nil
 }
 
-func gasCreateEip3860(_ *EVM, callContext *CallContext, availableGas uint64, memorySize uint64) (uint64, error) {
-	gas, err := memoryGasCost(callContext, memorySize)
+func gasCreateEip3860(evm *EVM, callContext *CallContext, availableGas uint64, memorySize uint64) (uint64, error) {
+	gas, err := memoryGasCost(evm, callContext, memorySize)
 	if err != nil {
 		return 0, err
 	}
@@ -322,7 +322,7 @@ func gasCreateEip3860(_ *EVM, callContext *CallContext, availableGas uint64, mem
 	}
 	numWords := ToWordSize(size)
 	// Since size <= params.MaxInitCodeSize, this multiplication cannot overflow
-	wordGas := params.InitCodeWordGas * numWords
+	wordGas := evm.GasSchedule.GetOr(GasKeyInitCodeWord, params.InitCodeWordGas) * numWords
 	gas, overflow = math.SafeAdd(gas, wordGas)
 	if overflow {
 		return 0, ErrGasUintOverflow
@@ -330,8 +330,8 @@ func gasCreateEip3860(_ *EVM, callContext *CallContext, availableGas uint64, mem
 	return gas, nil
 }
 
-func gasCreate2Eip3860(_ *EVM, callContext *CallContext, availableGas uint64, memorySize uint64) (uint64, error) {
-	gas, err := memoryGasCost(callContext, memorySize)
+func gasCreate2Eip3860(evm *EVM, callContext *CallContext, availableGas uint64, memorySize uint64) (uint64, error) {
+	gas, err := memoryGasCost(evm, callContext, memorySize)
 	if err != nil {
 		return 0, err
 	}
@@ -344,7 +344,7 @@ func gasCreate2Eip3860(_ *EVM, callContext *CallContext, availableGas uint64, me
 	}
 	numWords := ToWordSize(size)
 	// Since size <= params.MaxInitCodeSize, this multiplication cannot overflow
-	wordGas := (params.InitCodeWordGas + params.Keccak256WordGas) * numWords
+	wordGas := (evm.GasSchedule.GetOr(GasKeyInitCodeWord, params.InitCodeWordGas) + evm.GasSchedule.GetOr(GasKeyKeccak256Word, params.Keccak256WordGas)) * numWords
 	gas, overflow = math.SafeAdd(gas, wordGas)
 	if overflow {
 		return 0, ErrGasUintOverflow
@@ -352,11 +352,11 @@ func gasCreate2Eip3860(_ *EVM, callContext *CallContext, availableGas uint64, me
 	return gas, nil
 }
 
-func gasExpFrontier(_ *EVM, callContext *CallContext, availableGas uint64, memorySize uint64) (uint64, error) {
+func gasExpFrontier(evm *EVM, callContext *CallContext, availableGas uint64, memorySize uint64) (uint64, error) {
 	expByteLen := uint64(common.BitLenToByteLen(callContext.Stack.data[callContext.Stack.len()-2].BitLen()))
 
 	var (
-		gas      = expByteLen * params.ExpByteFrontier // no overflow check required. Max is 256 * ExpByte gas
+		gas      = expByteLen * evm.GasSchedule.GetOr(GasKeyExpByte, params.ExpByteFrontier) // no overflow check required. Max is 256 * ExpByte gas
 		overflow bool
 	)
 	if gas, overflow = math.SafeAdd(gas, params.ExpGas); overflow {
@@ -365,11 +365,11 @@ func gasExpFrontier(_ *EVM, callContext *CallContext, availableGas uint64, memor
 	return gas, nil
 }
 
-func gasExpEIP160(_ *EVM, callContext *CallContext, availableGas uint64, memorySize uint64) (uint64, error) {
+func gasExpEIP160(evm *EVM, callContext *CallContext, availableGas uint64, memorySize uint64) (uint64, error) {
 	expByteLen := uint64(common.BitLenToByteLen(callContext.Stack.data[callContext.Stack.len()-2].BitLen()))
 
 	var (
-		gas      = expByteLen * params.ExpByteEIP160 // no overflow check required. Max is 256 * ExpByte gas
+		gas      = expByteLen * evm.GasSchedule.GetOr(GasKeyExpByte, params.ExpByteEIP160) // no overflow check required. Max is 256 * ExpByte gas
 		overflow bool
 	)
 	if gas, overflow = math.SafeAdd(gas, params.ExpGas); overflow {
@@ -388,9 +388,9 @@ func statelessGasCall(evm *EVM, callContext *CallContext, availableGas uint64, m
 
 	transfersValue := !callContext.Stack.Back(2).IsZero()
 	if transfersValue {
-		gas += params.CallValueTransferGas
+		gas += evm.GasSchedule.GetOr(GasKeyCallValueXfer, params.CallValueTransferGas)
 	}
-	memoryGas, err := memoryGasCost(callContext, memorySize)
+	memoryGas, err := memoryGasCost(evm, callContext, memorySize)
 	if err != nil {
 		return 0, transfersValue, err
 	}
@@ -446,7 +446,7 @@ func statefulGasCall(evm *EVM, callContext *CallContext, gas uint64, availableGa
 			return 0, err
 		}
 		if transfersValue && empty {
-			accountGas = params.CallNewAccountGas
+			accountGas = evm.GasSchedule.GetOr(GasKeyCallNewAccount, params.CallNewAccountGas)
 			evm.IntraBlockState().MarkAddressAccess(address, false)
 		}
 	} else {
@@ -455,7 +455,7 @@ func statefulGasCall(evm *EVM, callContext *CallContext, gas uint64, availableGa
 			return 0, err
 		}
 		if !exists {
-			accountGas = params.CallNewAccountGas
+			accountGas = evm.GasSchedule.GetOr(GasKeyCallNewAccount, params.CallNewAccountGas)
 		}
 	}
 
@@ -491,7 +491,7 @@ func statefulGasCallCode(evm *EVM, callContext *CallContext, gas uint64, availab
 }
 
 func statelessGasCallCode(evm *EVM, callContext *CallContext, availableGas uint64, memorySize uint64, withCallGasCalc bool) (uint64, bool, error) {
-	memoryGas, err := memoryGasCost(callContext, memorySize)
+	memoryGas, err := memoryGasCost(evm, callContext, memorySize)
 	if err != nil {
 		return 0, false, err
 	}
@@ -500,7 +500,7 @@ func statelessGasCallCode(evm *EVM, callContext *CallContext, availableGas uint6
 		overflow bool
 	)
 	if !callContext.Stack.Back(2).IsZero() {
-		gas += params.CallValueTransferGas
+		gas += evm.GasSchedule.GetOr(GasKeyCallValueXfer, params.CallValueTransferGas)
 	}
 
 	if gas, overflow = math.SafeAdd(gas, memoryGas); overflow {
@@ -544,7 +544,7 @@ func statefulGasDelegateCall(evm *EVM, callContext *CallContext, gas uint64, ava
 }
 
 func statelessGasDelegateCall(evm *EVM, callContext *CallContext, availableGas uint64, memorySize uint64, withCallGasCalc bool) (uint64, bool, error) {
-	gas, err := memoryGasCost(callContext, memorySize)
+	gas, err := memoryGasCost(evm, callContext, memorySize)
 	if err != nil {
 		return 0, false, err
 	}
@@ -595,7 +595,7 @@ func statefulGasStaticCall(evm *EVM, callContext *CallContext, gas uint64, avail
 }
 
 func statelessGasStaticCall(evm *EVM, callContext *CallContext, availableGas uint64, memorySize uint64, withCallGasCalc bool) (uint64, bool, error) {
-	gas, err := memoryGasCost(callContext, memorySize)
+	gas, err := memoryGasCost(evm, callContext, memorySize)
 	if err != nil {
 		return 0, false, err
 	}
@@ -646,7 +646,7 @@ func gasSelfdestruct(evm *EVM, callContext *CallContext, availableGas uint64, me
 				return 0, err
 			}
 			if empty && !balance.IsZero() {
-				gas += params.CreateBySelfdestructGas
+				gas += evm.GasSchedule.GetOr(GasKeyCreateBySelfDestruct, params.CreateBySelfdestructGas)
 			}
 		} else {
 			exist, err := evm.IntraBlockState().Exist(address)
@@ -654,7 +654,7 @@ func gasSelfdestruct(evm *EVM, callContext *CallContext, availableGas uint64, me
 				return 0, err
 			}
 			if !exist {
-				gas += params.CreateBySelfdestructGas
+				gas += evm.GasSchedule.GetOr(GasKeyCreateBySelfDestruct, params.CreateBySelfdestructGas)
 			}
 		}
 	}
diff --git a/execution/vm/interpreter.go b/execution/vm/interpreter.go
index 8f62c8d..6b0575a 100644
--- a/execution/vm/interpreter.go
+++ b/execution/vm/interpreter.go
@@ -48,6 +48,10 @@ type Config struct {
 	RestoreState  bool // Revert all changes made to the state (useful for constant system calls)
 
 	ExtraEips []int // Additional EIPS that are to be enabled
+
+	// CustomJumpTable allows injecting a modified JumpTable for gas repricing simulation.
+	// When set, this JumpTable is used instead of the fork-based default.
+	CustomJumpTable *JumpTable
 }
 
 func (vmConfig *Config) HasEip3860(rules *chain.Rules) bool {
@@ -190,7 +194,18 @@ func copyJumpTable(jt *JumpTable) *JumpTable {
 	return &copy
 }
 
+// GetBaseJumpTable returns the base JumpTable for a given chain rules.
+// The returned JumpTable is a copy that can be safely modified.
+// This is used by gas repricing simulation to create custom JumpTables.
+func GetBaseJumpTable(chainRules *chain.Rules) *JumpTable {
+	return copyJumpTable(jumpTable(chainRules, Config{}))
+}
+
 func jumpTable(chainRules *chain.Rules, cfg Config) *JumpTable {
+	// If a custom JumpTable is provided, use it directly
+	if cfg.CustomJumpTable != nil {
+		return cfg.CustomJumpTable
+	}
 	var jt *JumpTable
 	switch {
 	case chainRules.IsAmsterdam:
diff --git a/execution/vm/jump_table.go b/execution/vm/jump_table.go
index e035ed2..2bc3c31 100644
--- a/execution/vm/jump_table.go
+++ b/execution/vm/jump_table.go
@@ -53,6 +53,17 @@ type operation struct {
 	string     stringer
 }
 
+// SetConstantGas sets the constant gas cost for an operation.
+// Used by custom JumpTable builders for gas repricing simulation.
+func (op *operation) SetConstantGas(gas uint64) {
+	op.constantGas = gas
+}
+
+// GetConstantGas returns the constant gas cost for an operation.
+func (op *operation) GetConstantGas() uint64 {
+	return op.constantGas
+}
+
 var (
 	frontierInstructionSet         = newFrontierInstructionSet()
 	homesteadInstructionSet        = newHomesteadInstructionSet()
diff --git a/execution/vm/operations_acl.go b/execution/vm/operations_acl.go
index 4b73547..b953071 100644
--- a/execution/vm/operations_acl.go
+++ b/execution/vm/operations_acl.go
@@ -52,7 +52,7 @@ func makeGasSStoreFunc(clearingRefund uint64) gasFunc {
 		current, _ = evm.IntraBlockState().GetState(callContext.Address(), slot)
 		// If the caller cannot afford the cost, this change will be rolled back
 		if _, slotMod := evm.IntraBlockState().AddSlotToAccessList(callContext.Address(), slot); slotMod {
-			cost = params.ColdSloadCostEIP2929
+			cost = evm.GasSchedule.GetOr(GasKeySloadCold, params.ColdSloadCostEIP2929)
 		}
 		var value uint256.Int
 		value.Set(y)
@@ -60,21 +60,22 @@ func makeGasSStoreFunc(clearingRefund uint64) gasFunc {
 		if current.Eq(&value) { // noop (1)
 			// EIP 2200 original clause:
 			//		return params.SloadGasEIP2200, nil
-			return cost + params.WarmStorageReadCostEIP2929, nil // SLOAD_GAS
+			return cost + evm.GasSchedule.GetOr(GasKeySloadWarm, params.WarmStorageReadCostEIP2929), nil // SLOAD_GAS
 		}
 
 		slotCommited := accounts.InternKey(x.Bytes32())
 		var original, _ = evm.IntraBlockState().GetCommittedState(callContext.Address(), slotCommited)
 		if original.Eq(&current) {
 			if original.IsZero() { // create slot (2.1.1)
-				return cost + params.SstoreSetGasEIP2200, nil
+				return cost + evm.GasSchedule.GetOr(GasKeySstoreSet, params.SstoreSetGasEIP2200), nil
 			}
 			if value.IsZero() { // delete slot (2.1.2b)
 				evm.IntraBlockState().AddRefund(clearingRefund)
 			}
 			// EIP-2200 original clause:
 			//		return params.SstoreResetGasEIP2200, nil // write existing slot (2.1.2)
-			return cost + (params.SstoreResetGasEIP2200 - params.ColdSloadCostEIP2929), nil // write existing slot (2.1.2)
+			// Use SafeSubClamp to prevent underflow with custom gas schedules
+			return cost + math.SafeSubClamp(evm.GasSchedule.GetOr(GasKeySstoreReset, params.SstoreResetGasEIP2200), evm.GasSchedule.GetOr(GasKeySloadCold, params.ColdSloadCostEIP2929)), nil // write existing slot (2.1.2)
 		}
 		if !original.IsZero() {
 			if current.IsZero() { // recreate slot (2.2.1.1)
@@ -87,19 +88,21 @@ func makeGasSStoreFunc(clearingRefund uint64) gasFunc {
 			if original.IsZero() { // reset to original inexistent slot (2.2.2.1)
 				// EIP 2200 Original clause:
 				//evm.StateDB.AddRefund(params.SstoreSetGasEIP2200 - params.SloadGasEIP2200)
-				evm.IntraBlockState().AddRefund(params.SstoreSetGasEIP2200 - params.WarmStorageReadCostEIP2929)
+				// Use SafeSubClamp to prevent underflow with custom gas schedules
+				evm.IntraBlockState().AddRefund(math.SafeSubClamp(evm.GasSchedule.GetOr(GasKeySstoreSet, params.SstoreSetGasEIP2200), evm.GasSchedule.GetOr(GasKeySloadWarm, params.WarmStorageReadCostEIP2929)))
 			} else { // reset to original existing slot (2.2.2.2)
 				// EIP 2200 Original clause:
 				//	evm.StateDB.AddRefund(params.SstoreResetGasEIP2200 - params.SloadGasEIP2200)
 				// - SSTORE_RESET_GAS redefined as (5000 - COLD_SLOAD_COST)
 				// - SLOAD_GAS redefined as WARM_STORAGE_READ_COST
 				// Final: (5000 - COLD_SLOAD_COST) - WARM_STORAGE_READ_COST
-				evm.IntraBlockState().AddRefund((params.SstoreResetGasEIP2200 - params.ColdSloadCostEIP2929) - params.WarmStorageReadCostEIP2929)
+				// Use SafeSubClamp to prevent underflow with custom gas schedules
+				evm.IntraBlockState().AddRefund(math.SafeSubClamp(math.SafeSubClamp(evm.GasSchedule.GetOr(GasKeySstoreReset, params.SstoreResetGasEIP2200), evm.GasSchedule.GetOr(GasKeySloadCold, params.ColdSloadCostEIP2929)), evm.GasSchedule.GetOr(GasKeySloadWarm, params.WarmStorageReadCostEIP2929)))
 			}
 		}
 		// EIP-2200 original clause:
 		//return params.SloadGasEIP2200, nil // dirty update (2.2)
-		return cost + params.WarmStorageReadCostEIP2929, nil // dirty update (2.2)
+		return cost + evm.GasSchedule.GetOr(GasKeySloadWarm, params.WarmStorageReadCostEIP2929), nil // dirty update (2.2)
 	}
 }
 
@@ -113,9 +116,9 @@ func gasSLoadEIP2929(evm *EVM, callContext *CallContext, scopeGas uint64, memory
 	// If the caller cannot afford the cost, this change will be rolled back
 	// If he does afford it, we can skip checking the same thing later on, during execution
 	if _, slotMod := evm.IntraBlockState().AddSlotToAccessList(callContext.Address(), accounts.InternKey(loc.Bytes32())); slotMod {
-		return params.ColdSloadCostEIP2929, nil
+		return evm.GasSchedule.GetOr(GasKeySloadCold, params.ColdSloadCostEIP2929), nil
 	}
-	return params.WarmStorageReadCostEIP2929, nil
+	return evm.GasSchedule.GetOr(GasKeySloadWarm, params.WarmStorageReadCostEIP2929), nil
 }
 
 // gasExtCodeCopyEIP2929 implements extcodecopy according to EIP-2929
@@ -134,7 +137,7 @@ func gasExtCodeCopyEIP2929(evm *EVM, callContext *CallContext, scopeGas uint64,
 	if evm.IntraBlockState().AddAddressToAccessList(addr) {
 		var overflow bool
 		// We charge (cold-warm), since 'warm' is already charged as constantGas
-		if gas, overflow = math.SafeAdd(gas, params.ColdAccountAccessCostEIP2929-params.WarmStorageReadCostEIP2929); overflow {
+		if gas, overflow = math.SafeAdd(gas, evm.GasSchedule.GetOr(GasKeyCallCold, params.ColdAccountAccessCostEIP2929)-evm.GasSchedule.GetOr(GasKeyCallWarm, params.WarmStorageReadCostEIP2929)); overflow {
 			return 0, ErrGasUintOverflow
 		}
 		return gas, nil
@@ -154,7 +157,7 @@ func gasEip2929AccountCheck(evm *EVM, callContext *CallContext, scopeGas uint64,
 	// If the caller cannot afford the cost, this change will be rolled back
 	if evm.IntraBlockState().AddAddressToAccessList(addr) {
 		// The warm storage read cost is already charged as constantGas
-		return params.ColdAccountAccessCostEIP2929 - params.WarmStorageReadCostEIP2929, nil
+		return evm.GasSchedule.GetOr(GasKeyCallCold, params.ColdAccountAccessCostEIP2929) - evm.GasSchedule.GetOr(GasKeyCallWarm, params.WarmStorageReadCostEIP2929), nil
 	}
 	return 0, nil
 }
@@ -164,7 +167,7 @@ func makeCallVariantGasCallEIP2929(oldCalculator gasFunc) gasFunc {
 		addr := accounts.InternAddress(callContext.Stack.Back(1).Bytes20())
 		// The WarmStorageReadCostEIP2929 (100) is already deducted in the form of a constant cost, so
 		// the cost to charge for cold access, if any, is Cold - Warm
-		coldCost := params.ColdAccountAccessCostEIP2929 - params.WarmStorageReadCostEIP2929
+		coldCost := evm.GasSchedule.GetOr(GasKeyCallCold, params.ColdAccountAccessCostEIP2929) - evm.GasSchedule.GetOr(GasKeyCallWarm, params.WarmStorageReadCostEIP2929)
 		warmAccess := evm.IntraBlockState().AddressInAccessList(addr)
 		if !warmAccess {
 			// Charge the remaining difference here already, to correctly calculate available
@@ -230,7 +233,7 @@ func makeSelfdestructGasFn(refundsEnabled bool) gasFunc {
 		)
 		// If the caller cannot afford the cost, this change will be rolled back
 		if !evm.IntraBlockState().AddressInAccessList(address) {
-			gas = params.ColdAccountAccessCostEIP2929
+			gas = evm.GasSchedule.GetOr(GasKeyCallCold, params.ColdAccountAccessCostEIP2929)
 			if _, ok := useGas(scopeGas, gas, evm.Config().Tracer, tracing.GasChangeCallStorageColdAccess); !ok {
 				return 0, ErrOutOfGas
 			}
@@ -248,7 +251,7 @@ func makeSelfdestructGasFn(refundsEnabled bool) gasFunc {
 		}
 		evm.IntraBlockState().MarkAddressAccess(address, false)
 		if empty && !balance.IsZero() {
-			gas += params.CreateBySelfdestructGas
+			gas += evm.GasSchedule.GetOr(GasKeyCreateBySelfDestruct, params.CreateBySelfdestructGas)
 		}
 
 		hasSelfdestructed, err := evm.IntraBlockState().HasSelfdestructed(callContext.Address())
@@ -279,7 +282,7 @@ func makeCallVariantGasCallEIP7702(statelessCalculator statelessGasFunc, statefu
 		if !evm.intraBlockState.AddressInAccessList(addr) {
 			// The WarmStorageReadCostEIP2929 (100) is already deducted in the form of a constant cost, so
 			// the cost to charge for cold access, if any, is Cold - Warm
-			accessGas = params.ColdAccountAccessCostEIP2929 - params.WarmStorageReadCostEIP2929
+			accessGas = evm.GasSchedule.GetOr(GasKeyCallCold, params.ColdAccountAccessCostEIP2929) - evm.GasSchedule.GetOr(GasKeyCallWarm, params.WarmStorageReadCostEIP2929)
 			// Charge the remaining difference here already, to correctly calculate available
 			// gas for call
 			if availableGas < accessGas {
@@ -327,9 +330,9 @@ func makeCallVariantGasCallEIP7702(statelessCalculator statelessGasFunc, statefu
 		var delegationGas uint64
 		if ok {
 			if !evm.intraBlockState.AddressInAccessList(dd) {
-				delegationGas = params.ColdAccountAccessCostEIP2929
+				delegationGas = evm.GasSchedule.GetOr(GasKeyCallCold, params.ColdAccountAccessCostEIP2929)
 			} else {
-				delegationGas = params.WarmStorageReadCostEIP2929
+				delegationGas = evm.GasSchedule.GetOr(GasKeyCallWarm, params.WarmStorageReadCostEIP2929)
 			}
 			_, err := evm.intraBlockState.GetCode(addr)
 			if err != nil {
diff --git a/node/cli/default_flags.go b/node/cli/default_flags.go
index 9a74504..5ff4a16 100644
--- a/node/cli/default_flags.go
+++ b/node/cli/default_flags.go
@@ -263,4 +263,6 @@ var DefaultFlags = []cli.Flag{
 
 	&utils.MCPAddrFlag,
 	&utils.MCPPortFlag,
+	// Xatu: Xatu execution processor flag
+	&utils.XatuConfigFlag,
 }
diff --git a/node/eth/backend.go b/node/eth/backend.go
index 7cbcd27..789f0b4 100644
--- a/node/eth/backend.go
+++ b/node/eth/backend.go
@@ -1154,8 +1154,23 @@ func (s *Ethereum) Init(stack *node.Node, config *ethconfig.Config, chainConfig
 		}
 	}
 
+	// Xatu: Initialize Xatu service if configured (requires -tags embedded)
+	var xatuAPIs []rpc.API
+	if config.XatuConfig != "" {
+		var xatuErr error
+		xatuAPIs, xatuErr = initXatu(stack, chainKv, s.blockReader, chainConfig, s.engine, config.XatuConfig, s.logger)
+		if xatuErr != nil {
+			return xatuErr
+		}
+	}
+
 	s.apiList = jsonrpc.APIList(chainKv, s.ethRpcClient, s.txPoolRpcClient, s.miningRpcClient, s.rpcFilters, s.rpcDaemonStateCache, blockReader, &httpRpcCfg, s.engine, s.logger, s.polygonBridge, s.heimdallService)
 
+	// Add Xatu simulation APIs if service is available
+	if len(xatuAPIs) > 0 {
+		s.apiList = append(s.apiList, xatuAPIs...)
+	}
+
 	if config.SilkwormRpcDaemon && httpRpcCfg.Enabled {
 		interface_log_settings := silkworm.RpcInterfaceLogSettings{
 			Enabled:         config.SilkwormRpcLogEnabled,
diff --git a/node/ethconfig/config.go b/node/ethconfig/config.go
index 33317ee..5684256 100644
--- a/node/ethconfig/config.go
+++ b/node/ethconfig/config.go
@@ -242,6 +242,8 @@ type Config struct {
 
 	// Ethstats service
 	Ethstats string
+	// Xatu: Xatu execution processor config path
+	XatuConfig string
 	// Consensus layer
 	InternalCL bool
 
