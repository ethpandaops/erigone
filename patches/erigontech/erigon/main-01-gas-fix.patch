diff --git a/execution/vm/gas.go b/execution/vm/gas.go
index ff18f09095..719b0a8822 100644
--- a/execution/vm/gas.go
+++ b/execution/vm/gas.go
@@ -39,6 +39,10 @@ const (
 // As part of EIP 150 (TangerineWhistle), the returned gas is gas - base * 63 / 64.
 func callGas(isEip150 bool, availableGas, base uint64, callCost *uint256.Int) (uint64, error) {
 	if isEip150 {
+		// Guard against underflow: if availableGas < base, no gas can be passed to the child call
+		if availableGas < base {
+			return 0, nil
+		}
 		availableGas = availableGas - base
 		gas := availableGas - availableGas/64
 		// If the bit length exceeds 64 bit we know that the newly calculated "gas" for EIP150
diff --git a/execution/vm/gas_table_test.go b/execution/vm/gas_table_test.go
index b3ccfaa50a..fea4066984 100644
--- a/execution/vm/gas_table_test.go
+++ b/execution/vm/gas_table_test.go
@@ -39,6 +39,8 @@ import (
 	"github.com/erigontech/erigon/db/state/execctx"
 	"github.com/erigontech/erigon/execution/chain"
 	"github.com/erigontech/erigon/execution/state"
+	"github.com/erigontech/erigon/execution/tracing"
+	"github.com/erigontech/erigon/execution/tracing/tracers/logger"
 	"github.com/erigontech/erigon/execution/types/accounts"
 	"github.com/erigontech/erigon/execution/vm"
 	"github.com/erigontech/erigon/execution/vm/evmtypes"
@@ -211,3 +213,185 @@ func TestCreateGas(t *testing.T) {
 	}
 	tx.Rollback()
 }
+
+// TestCallGasCostUnderflow tests for a bug where the gasCost reported by the tracer
+// is corrupted when a CALL with value transfer fails due to insufficient gas.
+//
+// Bug: In gas.go:callGas(), the subtraction `availableGas - base` underflows when
+// availableGas < base (e.g., 5000 available but CALL needs 9000 for value transfer).
+// This produces a huge gasCost value (~2^64) in the tracer output.
+//
+// Real-world example: tx 0x4a18dc6b1fbfbb7b0d7402c57e4e2bc4b16cef0dcb8eb690a2a01de9d629f043
+// had gasCost = 18158513697557845033 (0xfc00000000001429) for a CALL opcode.
+func TestCallGasCostUnderflow(t *testing.T) {
+	t.Parallel()
+
+	tx, sd := testTemporalTxSD(t)
+
+	r, w := state.NewReaderV3(sd.AsGetter(tx)), state.NewWriter(sd.AsPutDel(tx), nil, sd.TxNum())
+	s := state.New(r)
+
+	// Create the calling contract
+	callerAddr := accounts.InternAddress(common.BytesToAddress([]byte("caller")))
+	s.CreateAccount(callerAddr, true)
+	// Give the caller some ETH to transfer
+	_ = s.SetBalance(callerAddr, *uint256.NewInt(1_000_000_000_000_000_000), tracing.BalanceChangeUnspecified) // 1 ETH
+
+	// Target address for the CALL (doesn't need code, just needs to exist)
+	targetAddr := accounts.InternAddress(common.BytesToAddress([]byte("target")))
+	s.CreateAccount(targetAddr, true)
+
+	// Contract bytecode that mimics the real buggy transaction:
+	// The real tx did: GAS SUB to compute the gas argument, which underflowed
+	// because it subtracted a large value (0x8796 = 34710) from available gas (~5000).
+	//
+	// Bytecode plan:
+	// PUSH1 0x00   ; retSize = 0
+	// PUSH1 0x00   ; retOffset = 0
+	// PUSH1 0x00   ; argsSize = 0
+	// PUSH1 0x00   ; argsOffset = 0
+	// PUSH1 0x01   ; value = 1 wei (triggers CallValueTransferGas = 9000)
+	// PUSH20 <target> ; target address
+	// PUSH2 0x8796 ; large value to subtract (34710)
+	// GAS          ; push current gas
+	// SUB          ; GAS - 0x8796 = UNDERFLOW when gas < 34710!
+	// CALL         ; execute call with underflowed gas argument
+	// STOP
+	targetAddrValue := targetAddr.Value()
+	code := []byte{
+		0x60, 0x00, // PUSH1 0x00 (retSize)
+		0x60, 0x00, // PUSH1 0x00 (retOffset)
+		0x60, 0x00, // PUSH1 0x00 (argsSize)
+		0x60, 0x00, // PUSH1 0x00 (argsOffset)
+		0x60, 0x01, // PUSH1 0x01 (value = 1 wei)
+		0x73, // PUSH20
+	}
+	code = append(code, targetAddrValue[:]...)
+	code = append(code,
+		0x61, 0x87, 0x96, // PUSH2 0x8796 (34710 - large value to cause underflow)
+		0x5A, // GAS
+		0x03, // SUB (GAS - 0x8796 = underflow!)
+		0xF1, // CALL
+		0x00, // STOP
+	)
+
+	s.SetCode(callerAddr, code)
+
+	vmctx := evmtypes.BlockContext{
+		CanTransfer: func(_ evmtypes.IntraBlockState, _ accounts.Address, _ uint256.Int) (bool, error) {
+			return true, nil
+		},
+		Transfer: func(_ evmtypes.IntraBlockState, _, _ accounts.Address, _ uint256.Int, _ bool, _ *chain.Rules) error {
+			return nil
+		},
+	}
+	_ = s.CommitBlock(vmctx.Rules(chain.AllProtocolChanges), w)
+
+	// Set up the struct logger to capture gasCost values
+	structLogger := logger.NewStructLogger(nil)
+
+	vmenv := vm.NewEVM(vmctx, evmtypes.TxContext{}, s, chain.AllProtocolChanges, vm.Config{
+		Tracer: structLogger.Hooks(),
+	})
+
+	// Initialize the logger with the EVM context (required before tracing)
+	structLogger.OnTxStart(vmenv.GetVMContext(), nil, accounts.ZeroAddress)
+
+	// Call with limited gas:
+	//
+	// Gas breakdown before CALL opcode:
+	// - PUSH1 x 6 = 6 * 3 = 18 gas
+	// - PUSH20 = 3 gas
+	// - PUSH2 = 3 gas
+	// - GAS = 2 gas
+	// - SUB = 3 gas
+	// Total = 29 gas to reach CALL
+	//
+	// At CALL, the gas argument on the stack will be: (startGas - 29) - 34710
+	// If startGas < 34710 + 29 = 34739, the SUB will underflow in EVM.
+	//
+	// We want to trigger the bug in callGas(), which requires:
+	// availableGas < base (where base includes value transfer = 9000)
+	//
+	// Let's use enough gas to reach CALL but have the underflowed stack value.
+	startGas := uint64(10000)
+
+	t.Logf("Starting with gas: %d", startGas)
+
+	_, remainingGas, err := vmenv.Call(accounts.ZeroAddress, callerAddr, nil, startGas, uint256.Int{}, false)
+	t.Logf("Remaining gas: %d, Error: %v", remainingGas, err)
+
+	// The call should fail with out of gas
+	require.Error(t, err, "Expected out of gas error")
+
+	// Find the CALL opcode in the trace
+	logs := structLogger.StructLogs()
+	t.Logf("Total opcodes traced: %d", len(logs))
+
+	var callLog *logger.StructLog
+	for i := range logs {
+		t.Logf("Opcode %d: %s gas=%d gasCost=%d", i, logs[i].Op, logs[i].Gas, logs[i].GasCost)
+		if logs[i].Op == vm.CALL {
+			callLog = &logs[i]
+			break
+		}
+	}
+
+	require.NotNil(t, callLog, "Expected to find CALL opcode in trace")
+	t.Logf("CALL opcode: gas=%d, gasCost=%d (0x%x)", callLog.Gas, callLog.GasCost, callLog.GasCost)
+
+	// The bug: gasCost is corrupted due to underflow in callGas()
+	//
+	// Detection: The underflow produces values close to 2^64 (~18 quintillion).
+	// Any gasCost > 2^60 is definitely corrupted - no legitimate gas cost approaches
+	// 1 exagas. This threshold is robust against any future block gas limit changes.
+	//
+	// Note: gasCost > gas is also technically invalid (you can't consume more than
+	// you have), but Erigon returns computed base costs even for failed CALLs.
+	// Reth instead returns gasCost = gas (all available gas consumed).
+	const corruptionThreshold = uint64(1) << 60 // ~1.15 * 10^18
+
+	if callLog.GasCost > corruptionThreshold {
+		t.Errorf("BUG DETECTED: CALL gasCost is corrupted due to underflow!\n"+
+			"  gas (available) = %d\n"+
+			"  gasCost         = %d (0x%x)\n"+
+			"  threshold       = %d (2^60)\n"+
+			"  This is caused by underflow in gas.go:callGas() when availableGas < base",
+			callLog.Gas, callLog.GasCost, callLog.GasCost, corruptionThreshold)
+	} else {
+		t.Logf("CALL gasCost = %d (not corrupted)", callLog.GasCost)
+		// Additional info: check if gasCost exceeds available gas
+		if callLog.GasCost > callLog.Gas {
+			t.Logf("  Note: gasCost (%d) > gas (%d) - Erigon returns computed cost, Reth would return %d",
+				callLog.GasCost, callLog.Gas, callLog.Gas)
+		}
+	}
+}
+
+// TestCallGasUnderflowDirectly tests the callGas function directly for underflow.
+func TestCallGasUnderflowDirectly(t *testing.T) {
+	t.Parallel()
+
+	// Simulate the conditions that cause underflow:
+	// - availableGas = 5000 (gas remaining before CALL)
+	// - base = 9000 (CallValueTransferGas for value transfer)
+	// - callCost = huge 256-bit value (from underflowed stack computation)
+
+	availableGas := uint64(5000)
+	base := uint64(9000) // CallValueTransferGas
+
+	// In EIP-150 mode, callGas does: availableGas = availableGas - base
+	// When availableGas < base, this underflows!
+	if availableGas < base {
+		underflowedGas := availableGas - base // This wraps around to ~2^64 - 4000
+		t.Logf("Underflow detected: %d - %d = %d (0x%x)",
+			availableGas, base, underflowedGas, underflowedGas)
+
+		// The underflowed value should be close to 2^64
+		if underflowedGas > 1<<63 {
+			t.Logf("BUG CONFIRMED: Underflow produces huge value: %d", underflowedGas)
+		}
+	} else {
+		t.Log("No underflow (availableGas >= base)")
+	}
+}
